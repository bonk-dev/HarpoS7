using System.Buffers.Binary;
using System.Net.Sockets;
using System.Text;
using HarpoS7;
using HarpoS7.Auth;
using HarpoS7.Keys;
using HarpoS7.PoC;

// All "requests" were extracted from a Wireshark dump
// in a real library/app you would obviously serialize/deserialize these dynamically

var readBuffer = new byte[1024];
const string plcHost = "192.168.1.111";
const int plcS7Port = 102;

// Connect to the PLC
using var client = new TcpClient();

try
{
	await client.ConnectAsync(plcHost, plcS7Port);
}
catch (SocketException ex)
{
	Console.WriteLine($"[-] Could not connect to {plcHost}:{plcS7Port}");
	Console.WriteLine($"[-] Exception message: {ex.Message}");

	return;
}

Console.WriteLine($"[+] Connected to {plcHost}:{plcS7Port}");
var stream = client.GetStream();

// Send COTP Connection Request
var cotpConnectionRequest = new byte[] 
{
    0x03, 0x00, 0x00, 0x24, 0x1F, 0xE0, 0x00, 0x00, 0x00, 0x01, 0x00, 0xC1,
    0x02, 0x06, 0x00, 0xC2, 0x10, 0x53, 0x49, 0x4D, 0x41, 0x54, 0x49, 0x43,
    0x2D, 0x52, 0x4F, 0x4F, 0x54, 0x2D, 0x48, 0x4D, 0x49, 0xC0, 0x01, 0x0A
};

Console.WriteLine("Sending COTP CR...");
await stream.WriteAsync(cotpConnectionRequest);

Console.WriteLine("Waiting for COTP Connection Confirm");
_ = await stream.ReadAsync(readBuffer);

// write empty DT-Data
var emptyDtData = new byte[]
{
	0x03, 0x00, 0x00, 0x07, 0x02, 0xF0, 0x00
};
await stream.WriteAsync(emptyDtData);

// Send S7CommPlus CreateObject request (creates a session object on the PLC)
var createObjectRequest = new byte[] 
{
	0x03, 0x00, 0x01, 0x10, 0x02, 0xF0, 0x80, 0x72, 0x01, 0x01, 0x01, 0x31,
	0x00, 0x00, 0x04, 0xCA, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x20,
	0x36, 0x00, 0x00, 0x01, 0x1D, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA1, 0x00, 0x00, 0x00, 0xD3, 0x82, 0x1F, 0x00, 0x00, 0xA3, 0x81, 0x69,
	0x00, 0x15, 0x15, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x53, 0x65, 0x73,
	0x73, 0x69, 0x6F, 0x6E, 0x5F, 0x31, 0x43, 0x39, 0x43, 0x33, 0x38, 0x31,
	0xA3, 0x82, 0x21, 0x00, 0x15, 0x41, 0x30, 0x3A, 0x3A, 0x3A, 0x36, 0x2E,
	0x30, 0x3A, 0x3A, 0x41, 0x53, 0x49, 0x58, 0x20, 0x41, 0x58, 0x38, 0x38,
	0x31, 0x37, 0x39, 0x20, 0x55, 0x53, 0x42, 0x20, 0x33, 0x2E, 0x30, 0x20,
	0x74, 0x6F, 0x20, 0x47, 0x69, 0x67, 0x61, 0x62, 0x69, 0x74, 0x20, 0x45,
	0x74, 0x68, 0x65, 0x72, 0x6E, 0x65, 0x74, 0x20, 0x41, 0x64, 0x61, 0x70,
	0x74, 0x65, 0x72, 0x2E, 0x54, 0x43, 0x50, 0x49, 0x50, 0x2E, 0x31, 0xA3,
	0x82, 0x28, 0x00, 0x15, 0x0A, 0x52, 0x65, 0x61, 0x64, 0x20, 0x57, 0x72,
	0x69, 0x74, 0x65, 0xA3, 0x82, 0x29, 0x00, 0x15, 0x0B, 0x48, 0x4D, 0x49,
	0x20, 0x52, 0x54, 0x20, 0x4F, 0x4D, 0x53, 0x2B, 0xA3, 0x82, 0x2A, 0x00,
	0x15, 0x08, 0x59, 0x6F, 0x75, 0x72, 0x48, 0x6F, 0x73, 0x74, 0xA3, 0x82,
	0x2B, 0x00, 0x04, 0x02, 0xA3, 0x82, 0x2C, 0x00, 0x12, 0x01, 0xC9, 0xC3,
	0x81, 0xA3, 0x82, 0x2D, 0x00, 0x15, 0x0F, 0x52, 0x65, 0x61, 0x64, 0x2F,
	0x57, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x61, 0x67, 0x73, 0xA1, 0x00,
	0x00, 0x00, 0xD3, 0x81, 0x7F, 0x00, 0x00, 0xA3, 0x81, 0x69, 0x00, 0x15,
	0x15, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F,
	0x6E, 0x43, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x65, 0x72, 0xA2, 0xA2,
	0x00, 0x00, 0x00, 0x00, 0x72, 0x01, 0x00, 0x00
};

Console.WriteLine("Creating a session object");
await stream.WriteAsync(createObjectRequest);

Console.WriteLine("Waiting for create object response");
_ = await stream.ReadAsync(readBuffer);

await stream.WriteAsync(emptyDtData);

// again, you would normally deserialize the response packet
// and read the challenge array safely, instead of relying on byte offsets
const int rawChallengeArrayOffset = 0x7D;
const int rawChallengeArrayLength = 20;

// read the 20-long byte buffer (the challenge)
var challenge = readBuffer.AsMemory(rawChallengeArrayOffset, rawChallengeArrayLength);
Console.Write("Challenge: ");
Helpers.PrintBuffer(challenge);

// read the public key fingerprint
// the string length is serialized as a VLQ-encoded number

const int fingerprintLengthOffset = 0x37;
// max length of a 32-bit VLQ number is 5 (4+1) bytes
var fingerprintLength = Vlq.DecodeAsVlq32(readBuffer.AsSpan(fingerprintLengthOffset, 5), out var vlqLength);
var fingerprintValueOffset = fingerprintLengthOffset + vlqLength;

var fingerprintStringBytes = readBuffer.AsMemory(fingerprintValueOffset, (int)fingerprintLength);
var fingerprintString = Encoding.UTF8.GetString(fingerprintStringBytes.Span);

if (!fingerprintString.StartsWith("03:"))
{
    Console.WriteLine("[-] Fingerprint does not start with 03:");
    return;
}

Console.WriteLine($"Reversed fingerprint: {fingerprintString}");

// reverse string and parse fingerprint
var publicKeyFingerprint = new byte[Constants.KeyIdLength];
Helpers.ParseAndReverseBytes(fingerprintString, publicKeyFingerprint);

Console.Write("Actual fingerprint: ");
Helpers.PrintBuffer(publicKeyFingerprint);

// get the matching public key from the KeyStore
var publicKey = PublicKeyStore.GetPublicKey(publicKeyFingerprint);
if (publicKey == null)
{
    Console.WriteLine("[-] Public key for this fingerprint was not found in the key store. " +
                      "You need to find the appropriate key and add it to the key store.");
    return;
}

Console.WriteLine("[+] Public key found");

// create buffers
var sessionKey = new byte[Constants.SessionKeyLength];
var keyBlob = new byte[Constants.FinalBlobDataLength];

Console.WriteLine("Doing the encryption...");

// auth locally
LegacyAuthenticationScheme.Authenticate(
    keyBlob.AsSpan(),
    sessionKey.AsSpan(),
    challenge.Span,
    publicKey.AsSpan());

// construct metadata
var pubKeyId = new byte[Constants.KeyIdLength];
var sessionKeyId = new byte[Constants.KeyIdLength];

publicKey.DeriveKeyId(pubKeyId);
sessionKey.DeriveKeyId(sessionKeyId);

var pubKeyIdUlong = BinaryPrimitives.ReadUInt64LittleEndian(pubKeyId);
var sessionKeyIdUlong = BinaryPrimitives.ReadUInt64LittleEndian(sessionKeyId);

// construct the request
var setMultiVarsRequest = new byte[] {
	0x03, 0x00, 0x01, 0xB1, 0x02, 0xF0, 0x80, 0x72, 0x02, 0x01, 0xA2, 0x31,
	0x00, 0x00, 0x05, 0x42, 0x00, 0x00, 0x00, 0x02, 0x70, 0x40, 0x00, 0x00,
	0x34, 0x70, 0x40, 0x00, 0x00, 0x03, 0x03, 0x8E, 0x26, 0x82, 0x32, 0x82,
	0x2B, 0x01, 0x00, 0x17, 0x00, 0x00, 0x07, 0x08, 0x8E, 0x09, 0x00, 0x04,
	0x00, 0x8E, 0x0A, 0x00, 0x02, 0x00, 0x8E, 0x0B, 0x00, 0x17, 0x00, 0x00,
	0x07, 0x21, 0x8E, 0x22, 0x00, 0x05, 0xAD, 0xA6, 0xED, 0xB0, 0x8A, 0xFD,
	0x91, 0xD2, 0x84, 0x8E, 0x23, 0x00, 0x04, 0x86, 0x10, 0x8E, 0x24, 0x00,
	0x04, 0x00, 0x00, 0x8E, 0x0C, 0x00, 0x17, 0x00, 0x00, 0x07, 0x21, 0x8E,
	0x22, 0x00, 0x05, 0xC0, 0xF6, 0xA2, 0xAF, 0xDC, 0xC9, 0xBC, 0xBB, 0xBE,
	0x8E, 0x23, 0x00, 0x04, 0x84, 0x86, 0x01, 0x8E, 0x24, 0x00, 0x04, 0x00,
	0x00, 0x8E, 0x0D, 0x00, 0x14, 0x00, 0x81, 0x58, 0xAD, 0xDE, 0xE1, 0xFE,
	0xD8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xBE, 0x3B, 0x5E, 0x92, 0xFB, 0x12, 0xD9, 0x81, 0x01, 0x03, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x84, 0xD2, 0x48, 0x5F, 0x01, 0x6B, 0x9B, 0x5A,
	0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9D, 0xE7, 0x29, 0xE7,
	0x42, 0x0D, 0x09, 0x14, 0xF3, 0x2F, 0x62, 0x49, 0x35, 0x79, 0x2B, 0xBC,
	0x5D, 0xAB, 0xDB, 0x36, 0x98, 0x91, 0xE8, 0x93, 0xB0, 0x4E, 0x2A, 0x84,
	0x74, 0xB5, 0x98, 0xD8, 0xC2, 0xBF, 0x2F, 0x5C, 0x85, 0x2F, 0x8B, 0xAC,
	0x94, 0x07, 0x7F, 0xE9, 0xC5, 0xFF, 0x40, 0x8F, 0x2C, 0x98, 0xFD, 0x39,
	0xBF, 0x30, 0x28, 0xFB, 0x01, 0xAE, 0x40, 0x26, 0x9B, 0x69, 0xE8, 0xE4,
	0xA5, 0x2D, 0x6C, 0x32, 0x88, 0x5F, 0x15, 0x05, 0x64, 0x15, 0x10, 0x64,
	0xF6, 0xE5, 0x6D, 0x24, 0x94, 0x14, 0xBC, 0xFD, 0xE8, 0x65, 0x46, 0x9E,
	0x15, 0x56, 0x08, 0xFB, 0x01, 0x93, 0x5A, 0x7D, 0xD5, 0xA9, 0xCA, 0xD1,
	0xEF, 0x90, 0x8F, 0x92, 0x26, 0xAB, 0x47, 0xED, 0x42, 0x6F, 0x86, 0xE2,
	0x1F, 0x05, 0x88, 0x7D, 0xDB, 0xBF, 0x6A, 0xC7, 0x0C, 0x08, 0x62, 0x53,
	0xFB, 0xA6, 0xAC, 0xE3, 0x1D, 0x12, 0x7F, 0x27, 0x28, 0xF1, 0x4B, 0xAF,
	0x1A, 0x86, 0x62, 0x7D, 0xD0, 0x96, 0x03, 0x01, 0x1A, 0x6B, 0xDF, 0xE8,
	0x44, 0xC6, 0xA6, 0xD8, 0x09, 0x45, 0xA3, 0x86, 0x46, 0xCF, 0xB1, 0x81,
	0x1E, 0xF6, 0x14, 0x7F, 0x46, 0xEA, 0x10, 0xFB, 0x00, 0x02, 0x00, 0x17,
	0x00, 0x00, 0x01, 0x3A, 0x82, 0x3B, 0x00, 0x04, 0x85, 0x40, 0x82, 0x3C,
	0x00, 0x04, 0x85, 0x00, 0x82, 0x3D, 0x00, 0x04, 0x84, 0x80, 0xC1, 0x00,
	0x82, 0x3E, 0x00, 0x04, 0x84, 0x80, 0xC1, 0x00, 0x82, 0x3F, 0x00, 0x15,
	0x00, 0x82, 0x40, 0x00, 0x15, 0x00, 0x82, 0x41, 0x00, 0x03, 0x00, 0x03,
	0x00, 0x03, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x04, 0xE8, 0x89, 0x69,
	0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x89, 0x6A, 0x00, 0x13, 0x00, 0x89,
	0x6B, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x02, 0x00,
	0x00
};

const int publicKeyIdOffset = 0x42;
const int sessionKeyIdOffset = publicKeyIdOffset + 33;

pubKeyIdUlong.EncodeAsVlq(setMultiVarsRequest.AsSpan(publicKeyIdOffset));
sessionKeyIdUlong.EncodeAsVlq(setMultiVarsRequest.AsSpan(sessionKeyIdOffset));

// write the blob
const int encryptedKeyBlobOffset = 0x80;
keyBlob.CopyTo(setMultiVarsRequest.AsSpan(encryptedKeyBlobOffset));

// send request
Console.WriteLine("Sending a set multi vars request");
await stream.WriteAsync(setMultiVarsRequest);

var tokenSource = new CancellationTokenSource();
tokenSource.CancelAfter(3000);
Console.WriteLine("Waiting for a set var response...");

int read;
try
{
	read = await stream.ReadAsync(readBuffer, tokenSource.Token);
}
catch (OperationCanceledException)
{
	Console.WriteLine("[-] No response after 3000 ms - authentication failed");
	return;
}

if (read <= 0)
{
	Console.WriteLine("[-] The PLC sent an empty response");
	return;
}

// an approximation of the return value field (should be all 0x00).
// I might included the integrity id field or the unknown field by accident;
// these should be all 0x00 anyways.
const int returnValueOffset = 0x15;
const int returnValueLength = 7;
for (var i = returnValueOffset; i < returnValueOffset + returnValueLength; ++i)
{
	if (readBuffer[i] != 0x00)
	{
		Console.WriteLine("[-] Looks like an error has occured. Check if the ReturnValue field is 0x00 (OK)");
		return;
	}
}

Console.WriteLine("[++] Success! Looks like the authentication was successful. Check the packet dump (e.g. in Wireshark) to be sure.");